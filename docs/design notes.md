Из условий задачи видим следующее:
- у сотрудника есть рабочее время с X часов по Y. Режим работы может и будет меняться
- интервал каждого слота - 15 минут. Это значение может и будет меняться
- клиенту нужно вывести список доступных [[Слот|слотов]] с учетом запрошенного времени (45 минут). Это значение может и будет меняться
- [[Слот]] имеет произвольное время начала, и произвольную длительность
## Лаг

В условии задачи этого нет, но опыт подсказывает, что между слотами сотруднику нужно будет время чтобы подготовиться к приему следующего клиента. Желательно предусмотреть возможность добавить произвольный [[Лаг]] после каждого слота (например, массажисту нужно N минут чтобы подготовить стол, помыть руки, сходить на перекур).
## Выделяю следующие компоненты:
- [[SeanceReservationRequest]] - запрос сеанса с произвольной длительностью у конкретного [[Партнер|партнёра]]
- [[SeancePlanningService]] - сервис, который будет получать на вход [[SeanceReservationRequest|запрос сеанса]], и в ответ [[GetAvailableSlots|выдавать список доступных слотов]]
## Проблема гибкого старта слота
Проблема с гибким стартом слота в том, что если запрошен сеанс длительностью 1 час, а у сотрудника свободное время с 15 до 18, то мы не можем просто выдать клиенту варианты `15-16`, `16-17`, `17-18`, потому что клиент может запросить слот с `15:15` до `16:15`, или, например, с `16:37` до `17:37`.

В ТЗ мы видим четкий 15мин интервал. Интервал может и будет меняться.

Не будем мудрить с высокой точностью (16:3**7**-17:2**2** для сеанса 45 минут, или с точностью до милисекунд, т.к. в этой предметной области нет смысла), и разобьём на интервалы, из них будем строить слоты.
## Алгоритм

Для примера будем использовать:
- длительность сеанса: 45мин
- режим работы с 9 до 20
- время с 12-16:30 занято 
- лаг 5 минут

Вычисляем [[Свободный сегмент|свободные сегменты времени специалиста]]
> Получаем 09:00-12:00, 16:30-20:00

Преобразовываем границы сегмента в timestamp'ы, чтобы дальше сравнивать int'ы.

Вычисляем `выделяемое на сеанс время = длительность сеанса + лаг`, преобразовываем в количество секунд (unix timestamp в секундах, не будем мудрить с конвертацией).

Если `длительность сегмента` меньше чем `выделяемое на сеанс время` - пропускаем сегмент, т.к. сеанс не поместится.

В for цикле для каждого сегмента вычисляем `время начала слота = выделяемое на сеанс время + интервал`. (`интервал` добавляем ко всем кроме первого), и время окончания слота (`время начала + выделяемое на сеанс время`).

Когда время окончания выходит за границу сегмента - переходим к следующему сегменту.  

1. 09:00 + (00:45) + (00:05) = 09:50 (для первой итерации интервал не прибавляем)
2. 09:00 + 00:15 (интервал)+ (00:45) + (00:05) = 10:05
3. 09:30 + (00:45) + (00:05) = 10:20

Таким образом для каждого [[Свободный сегмент|сегмента]] мы соберем доступные слоты (время начала сеанса) и вернем их.
